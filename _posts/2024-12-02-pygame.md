---
layout: post
title:  'ğŸ® ê²Œì„ ê°œë°œê¸°: ìŠˆíŒ… ê²Œì„ ë§Œë“¤ê¸°'
date:   2024-12-03
categories: [opensource, study]
author: eoyeon
pin: true
---

# ğŸ® ê²Œì„ ê°œë°œê¸°: "Shooting Game" ì œì‘ê¸°

2024í•™ë…„ 2í•™ê¸° ì˜¤í”ˆì†ŒìŠ¤ SW ê°œë°œ ê°•ì˜ ì¤‘ì— ê²Œì„ì„ í•˜ë‚˜ ë§Œë“œëŠ” ê³¼ì œê°€ ìˆì—ˆëŠ”ë°ìš”,  
ì´ë²ˆ í¬ìŠ¤íŒ…ì—ì„œëŠ” ê·¸ ê³¼ì •ì„ ì†Œê°œí•´ ë“œë¦´ê¹Œ í•´ìš”. OwO!!

---

## 0. ê²Œì„ ì†Œê°œ  

ì¼ë‹¨ ìŠˆíŒ… ê²Œì„ì„ ë§Œë“¤ê¸°ë¡œ í•œ ì´ìœ ë¶€í„° ë§ì”€ë“œë¦´ê²Œìš”.  
ë‹¤ë¥¸ ì¥ë¥´ì— ë¹„í•´ í™œë™ì„±ì´ ë†’ê³ , ìˆ˜ì •í•˜ê±°ë‚˜ ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ë¶€ë¶„ì´ ë§ì•„ ë³´ì˜€ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤..  
êµ¬ê¸€ê³¼ ê¹ƒí—ˆë¸Œë¥¼ í†µí•˜ì—¬ ì—¬ëŸ¬ ì½”ë“œë¥¼ ì°¾ì•„ë³´ë‹¤ê°€... ìŠˆíŒ…ê²Œì„ì˜ í•œ ì½”ë“œë¡œ ê²°ì •ì„ í–ˆìŠµë‹ˆë‹¤ !

**ê¸°ë°˜ ì½”ë“œ**
```python
from tkinter import *
import time
import math
import random
import sys

window = Tk()
window.title("ì¢…ê°•ì„ í–¥í•´ ì´ë¼!")  # ê²Œì„ ì´ë¦„
window.resizable(0, 0)
canvas = Canvas(window, width=640, height=640, bg="White")  # ì°½ ìƒì„±


objects, enemyObjects, score = set(), set(), 0  # ì˜¤ë¸Œì íŠ¸ ì„¸íŠ¸, ì ìˆ˜ ì„ ì–¸



class Game:
    def __init__(self):
        global objects, enemyObjects, score
        self.keys = set()  # ë²„íŠ¼ ì„¸íŠ¸ ìƒì„±
        self.mx, self.my = 0, 0  # ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì´ˆê¸°í™”
        self.runtime, self.spontime = 0, 300  # ëŸ°íƒ€ì„, ìŠ¤í°íƒ€ì„
        self.hp_before, self.score_before = 0, 0  # ê°±ì‹ ìš© ì§€ì—­ë³€ìˆ˜
        self.enemyvalue = [[50, "skyblue"], [30, "gray"], [15, "brown"], [10, "black"]]  # ì  ì •ë³´
        window.bind("<KeyPress>", self.keyPressHandler)  # í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
        window.bind("<KeyRelease>", self.keyReleaseHandler)  # í‚¤ë³´ë“œ ì…ë ¥ í•´ì œ ì²˜ë¦¬
        canvas.bind("<Motion>", self.mouseMove)  # ë§ˆìš°ìŠ¤ ì´ë™ ì¶”ì 
        canvas.pack()

        canvas.create_text(320, 60, text="ğŸ˜•ì¢…ê°•ì„ í–¥í•´ ì´ë¼!ğŸ”«", fill="Black", font=("ë‘¥ê·¼ëª¨ê¼´", 28))  # ì„¤ëª…
        canvas.create_rectangle(100, 200, 135, 235, fill="lightgreen", outline="Black");
        canvas.create_text(117, 217, text="A", fill="Black", font=("ë‘¥ê·¼ëª¨ê¼´", 16))
        canvas.create_rectangle(143, 200, 178, 235, fill="lightgreen", outline="Black");
        canvas.create_text(160, 217, text="S", fill="Black", font=("ë‘¥ê·¼ëª¨ê¼´", 16))
        canvas.create_rectangle(186, 200, 221, 235, fill="lightgreen", outline="Black");
        canvas.create_text(203, 217, text="D", fill="Black", font=("ë‘¥ê·¼ëª¨ê¼´", 16))
        canvas.create_rectangle(143, 157, 178, 192, fill="lightgreen", outline="Black");
        canvas.create_text(160, 174, text="W", fill="Black", font=("ë‘¥ê·¼ëª¨ê¼´", 16))
        canvas.create_text(160, 270, text="< í”Œë ˆì´ì–´(í•™ìƒ) >", fill="Black", font=("ë‘¥ê·¼ëª¨ê¼´", 12))
        canvas.create_rectangle(450, 157, 510, 235, outline="Black");
        canvas.create_line(480, 187, 510, 187, fill="Black");
        canvas.create_rectangle(450, 157, 480, 187, fill="lightblue", outline="white")
        canvas.create_text(480, 270, text="< ì  >", fill="Black", font=("ë‘¥ê·¼ëª¨ê¼´", 12))
        canvas.create_text(300, 400, text="    ê³µê²©í•´ì˜¤ëŠ” ê³¼ì œë“¤ì„ í”¼í•´ ì£½ì´ëŠ” ê²Œì„ì…ë‹ˆë‹¤!\n\n    ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ê³¼ì œê°€ ë” ê°•í•´ì§‘ë‹ˆë‹¤! ", fill="slategray",
                          font=("ë‘¥ê·¼ëª¨ê¼´", 12))
        canvas.create_text(300, 400, text="\n\n\n\n\n\n\n\n\n\n\n\n     ì‘ìš©SWê°œë°œ | [bravo] | ì´ìˆ˜ë¯¼, ê¹€ì–´ì—°, ê¹€ìš°ë¦¬, ì•ˆìš°í˜", fill="cornflowerblue",
                          font=("ë‘¥ê·¼ëª¨ê¼´", 10))

        self.textblinker()  # ì‹œì‘ ëŒ€ê¸°

        # ê²Œì„ ì‹œì‘ ëŒ€ê¸° í™”ë©´
        self.textblinker()

        # ìºë¦­í„°(í”Œë ˆì´ì–´) ìƒì„±
        obj_main = object_main(316, 316, 8, 8, "purple")  # í”Œë ˆì´ì–´ ê°ì²´ ìƒì„±

        # ì ìˆ˜ì™€ HP í‘œì‹œ
        score_view = canvas.create_text(540, 15, text="SCORE: " + str(score), fill="Black", font=("Arial", 16))
        canvas.create_rectangle(5, 5, 420, 25, fill="White")  # HPë°” ë°”íƒ• ë“œë¡œìš°
        hpbar = canvas.create_rectangle(5, 5, 420, 25, fill="White", width=0)
        hptext = canvas.create_text(200, 15, text="HP: (" + str(obj_main.hp) + " / 1000)", font=("Arial", 8))

        # ê²Œì„ ë©”ì¸ ë£¨í”„
        while obj_main in objects:
            for key in self.keys:
                if key == ord('A') and obj_main.x_accel > -3: obj_main.x_accel -= 1  # A
                if key == ord('D') and obj_main.x_accel < 3: obj_main.x_accel += 1  # D
                if key == ord('W') and obj_main.y_accel > -3: obj_main.y_accel -= 1  # W
                if key == ord('S') and obj_main.y_accel < 3: obj_main.y_accel += 1  # S

            # ë§ˆìš°ìŠ¤ í´ë¦­ ì—†ì´ ìë™ìœ¼ë¡œ íˆ¬ì‚¬ì²´ ë°œì‚¬
            if obj_main.coolt == obj_main.cool:
                obj_attack = object_attack(canvas.coords(obj_main.canvas_id)[0] + 8,
                                           canvas.coords(obj_main.canvas_id)[1] + 8, 3, 3, "purple", 120)
                obj_attack.x_accel, obj_attack.y_accel = self.movePoint(
                    canvas.coords(obj_attack.canvas_id)[0] + 10,
                    canvas.coords(obj_attack.canvas_id)[1] + 10,
                    self.mx, self.my, 25)  # ë§ˆìš°ìŠ¤ ì¢Œí‘œë¡œ íˆ¬ì‚¬ì²´ ì´ë™
                obj_main.coolt = 0  # ì¿¨íƒ€ì„ ì´ˆê¸°í™”

            if self.hp_before != obj_main.hp:  # hp ê°±ì‹ 
                   canvas.delete(hpbar);
                   canvas.delete(hptext)
                   hpbar = canvas.create_rectangle(5, 5, 420 * obj_main.hp / obj_main.mhp, 25, fill="pink",
                                                   width=0)
                   hptext = canvas.create_text(200, 15, text="HP: (" + str(obj_main.hp) + " / 1000)",
                                               font=("ë‘¥ê·¼ëª¨ê¼´", 12))
                   self.hp_before = obj_main.hp
            if self.score_before != score:  # ì ìˆ˜ ê°±ì‹ 
                   canvas.itemconfig(score_view, text="SCORE: " + str(score))
                   self.score_before = score

            self.runtime += 1  # ëŸ°íƒ€ì„ ì¦ê°€

            if len(enemyObjects) < 25:  # ì  ê°œì²´ ìˆ˜ ì œí•œ
                if self.runtime % self.spontime == 0:  # 100 ë£¨í”„ë§ˆë‹¤ ì  ìƒì„±
                    for i in range(4):
                        if self.runtime % (self.spontime * (i + 1) ** 2) == 0: obj_enemy = object_enemy(
                            random.choice([-100, 740]) + random.randrange(-50, 50),
                            random.choice([-100, 740]) + random.randrange(-50, 50), self.enemyvalue[i][0],
                            self.enemyvalue[i][0], self.enemyvalue[i][1], obj_main, i)  # enemy ì˜¤ë¸Œì íŠ¸ ìŠ¤í°

                    self.spontime = max([random.randrange(self.spontime - 2, self.spontime), 50])  # ìŠ¤í°ì‹œê°„ ì´ˆê¸°í™”

                for obj in enemyObjects.copy():
                    degree = math.atan2(canvas.coords(obj_main.canvas_id)[0] - canvas.coords(obj.canvas_id)[0],
                                        canvas.coords(obj_main.canvas_id)[1] - canvas.coords(obj.canvas_id)[1])
                    obj.x_accel, obj.y_accel = -obj.enemy_stat[obj.enemy_type][1] * math.cos(degree), 5 * math.sin(
                        degree)  # main ì˜¤ë¸Œì íŠ¸ ê³µì „
                    if obj.coolt == obj.cool:
                        obj_enemyAttack = object_enemyAttack(
                            canvas.coords(obj.canvas_id)[0] + (obj.size_x - obj.enemy_stat[obj.enemy_type][3]) / 2,
                            canvas.coords(obj.canvas_id)[1] + (obj.size_y - obj.enemy_stat[obj.enemy_type][3]) / 2,
                            obj.enemy_stat[obj.enemy_type][3], obj.enemy_stat[obj.enemy_type][3], obj.color, 100,
                            obj_main, obj.enemy_stat[obj.enemy_type][5])  # obj_enemyAttack ìƒì„±
                        obj_enemyAttack.x_accel, obj_enemyAttack.y_accel = self.movePoint(
                            canvas.coords(obj_enemyAttack.canvas_id)[0] + random.randrange(-5, 5),
                            canvas.coords(obj_enemyAttack.canvas_id)[1] + random.randrange(-5, 5),
                            canvas.coords(obj_main.canvas_id)[0] + 10, canvas.coords(obj_main.canvas_id)[1] + 10,
                            obj.enemy_stat[obj.enemy_type][4])
                        obj.coolt = 0

            for obj in objects.copy():
                obj.move();
                obj.step()
            if not obj_main in objects:
                canvas.delete("all");
                break
            window.update(); # ui ë³€ê²½ì‚¬í•­ ì¦‰ì‹œ ì €ì¥
            time.sleep(0.01)  # 0.01ì´ˆ ë§Œí¼ sleep

        canvas.create_text(320, 260, text="ê³¼ì œë“¤ì„ ì´ê²¨ë‚´ì§€ ëª»í–ˆìŠµë‹ˆë‹¤...", fill="Black", font=("ë‘¥ê·¼ëª¨ê¼´", 38));
        canvas.create_text(320, 370, text=str(score) + " ì ", fill="Black", font=("ë‘¥ê·¼ëª¨ê¼´", 28))
        self.textblinker("ì¢…ê°• ì‹¤íŒ¨")  # ì¢…ë£Œ ëŒ€ê¸°
        sys.exit(1)

    def keyPressHandler(self, event):  # ë²„íŠ¼ ì„¸íŠ¸ì— ë²„íŠ¼ì¶”ê°€
       self.keys.add(event.keycode)

    def keyReleaseHandler(self, event):  # ë²„íŠ¼ ì„¸íŠ¸ì— ë²„íŠ¼ ì œê±°
       if event.keycode in self.keys: self.keys.remove(event.keycode)

    def mouseMove(self, event):
        self.mx, self.my = event.x, event.y  # ë§ˆìš°ìŠ¤ ì´ë™ ì‹œ ì¢Œí‘œ ê°±ì‹ 

    def movePoint(self, x1, y1, x2, y2, spd):  # í•´ë‹¹ ì¢Œí‘œë¡œ ì´ë™
       return (x2 - x1) * spd / math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2), (y2 - y1) * spd / math.sqrt(
           (x2 - x1) ** 2 + (y2 - y1) ** 2)

    def textblinker(self, sentance="start"):  # ëŒ€ê¸° í…ìŠ¤íŠ¸
        menuToggle = True;
        blinkerText = canvas.create_text(320, 580, text="< Please pless spacebar to " + sentance + ". >", fill="red",
                                        font=("ë‘¥ê·¼ëª¨ê¼´", 12))  # ê¹œë°•ì´ canvas ìƒì„±
        while (True):  # ëŒ€ê¸°
            self.runtime += 1
            for key in self.keys:  # spacebar ëˆ„ë¥¼ì‹œ ë‹¤ìŒìœ¼ë¡œ
                if key == 32:
                    canvas.delete("all");
                    return
            if self.runtime % 60 == 0:
                if menuToggle == True:
                    canvas.itemconfig(blinkerText, text="");
                    menuToggle = False
                else:
                    canvas.itemconfig(blinkerText, text="< Please pless spacebar to " + sentance + ". >");
                    menuToggle = True
            window.update();
            time.sleep(0.01)



# ì˜¤ë¸Œì íŠ¸ í´ë˜ìŠ¤ ì •ì˜
class element:
    def   collision(self, obj):
        self_coords = canvas.coords(self.canvas_id)
        obj_coords = canvas.coords(obj.canvas_id)
        # ì¶©ëŒ ì—¬ë¶€ë¥¼ íŒë‹¨í•˜ëŠ” ì¡°ê±´
        return (self_coords[0] < obj_coords[2] and
                self_coords[2] > obj_coords[0] and
                self_coords[1] < obj_coords[3] and
                self_coords[3] > obj_coords[1])

    def __init__(self, x, y, size_x, size_y, color):
        self.x, self.y = x, y  # ìƒì„± ìœ„ì¹˜
        self.size_x, self.size_y = size_x, size_y  # í¬ê¸°
        self.color = color  # ìƒ‰
        self.x_accel, self.y_accel = 0, 0  # ê°€ì†ë„
        objects.add(self)  # ì˜¤ë¸Œì íŠ¸ ì„¸íŠ¸ì— ìì‹  ë“±ë¡
        self.canvas_id = canvas.create_rectangle(x, y, x + self.size_x, y + self.size_y, fill=self.color,
                                                width=0)  # ìº ë²„ìŠ¤ ì¶”ê°€


    def destroy(self):
        # ê°ì²´ê°€ ì´ë¯¸ canvasì—ì„œ ì œê±°ë˜ì—ˆëŠ”ì§€ í™•ì¸ í›„ ì œê±°
        if hasattr(self, 'canvas_id') and self.canvas_id is not None:
            objects.discard(self)  # ì˜¤ë¸Œì íŠ¸ ì„¸íŠ¸ì—ì„œ ì œê±°
            canvas.delete(self.canvas_id)  # ìº ë²„ìŠ¤ì—ì„œ ì œê±°
            self.canvas_id = None  # ë” ì´ìƒ ìœ íš¨í•˜ì§€ ì•Šë„ë¡ ì„¤ì •
            del self

    def move(self):
        # self.canvas_idê°€ ìœ íš¨í•œì§€ í™•ì¸ í›„ ì²˜ë¦¬
        if hasattr(self, 'canvas_id') and self.canvas_id is not None:
            x_value, y_value = self.x_accel, self.y_accel
            if x_value != 0 or y_value != 0:
                coords = canvas.coords(self.canvas_id)
                if coords:
                    if coords[0] + x_value < 0: x_value, self.x_accel = -coords[0], -self.x_accel
                    if coords[1] + y_value < 30: y_value, self.y_accel = 30 - coords[1], -self.y_accel
                    if coords[2] + x_value > 640: x_value, self.x_accel = 640 - coords[2], -self.x_accel
                    if coords[3] + y_value > 640: y_value, self.y_accel = 640 - coords[3], -self.y_accel
                    canvas.move(self.canvas_id, x_value, y_value)
                    self.x_accel, self.y_accel = self.x_accel * 0.98, self.y_accel * 0.98

    def step(self):
        pass  # ë¹ˆ í•¨ìˆ˜ë¡œ ì •ì˜ (ë‹¤ë¥¸ ê°ì²´ì—ì„œ ìƒì†í•˜ì—¬ ì‚¬ìš©)

class object_main(element):  # main ì˜¤ë¸Œì íŠ¸
    def __init__(self, x, y, size_x, size_y, color):
        super().__init__(x, y, 16, 16, color)  # ìƒì†
        self.mhp, self.hp = 1000, 1000  # ì²´ë ¥
        self.cool, self.coolt = 10, 0  # ì¿¨íƒ€ì„

    def step(self):  # ìŠ¤í… í•¨ìˆ˜
        if self.coolt < self.cool:
            self.coolt += 1  # ì¿¨íƒ€ì„ ê°ì†Œ
        if self.hp <= 0:
            self.destroy()  # HP <= 0 ì¼ì‹œ ì œê±°


class object_enemy(element):  # enemy ì˜¤ë¸Œì íŠ¸
    def __init__(self, x, y, size_x, size_y, color, obj_main, enemy_type):
        super().__init__(x, y, size_x, size_y, color)  # ìƒì†
        self.enemy_stat = [[100, 2, 30, 3, 10, 20], [500, 1, 75, 5, 11, 30], [150, 3, 10, 3, 15, 50],
                           [2500, 1, 30, 6, 12, 80]]  # HP, ì†ë„, ê³µê²©ì†ë„, íˆ¬ì‚¬ì²´ í¬ê¸°, íˆ¬ì‚¬ì²´ ì†ë„, ë°ë¯¸ì§€
        self.enemy_type = enemy_type
        self.mhp = self.enemy_stat[self.enemy_type][0]
        self.hp = self.mhp  # ì²´ë ¥
        self.cool, self.coolt = self.enemy_stat[self.enemy_type][2], 0  # ì¿¨íƒ€ì„
        enemyObjects.add(self)  # enemy ì˜¤ë¸Œì íŠ¸ ì„¸íŠ¸ì— ìì‹  ë“±ë¡
        self.obj_main = obj_main  # obj_main ì˜¤ë¸Œì íŠ¸ ë°›ê¸°

        # ì ì˜ ì¤‘ì•™ì— í‘œì‹œí•  "ê³¼ì œ" ë˜ëŠ” "ìˆ˜ì—…" í…ìŠ¤íŠ¸ ìƒì„±
        self.label = "ê³¼ì œ" if random.random() < 0.5 else "ìˆ˜ì—…"
        self.label_id = canvas.create_text(self.x + size_x // 2, self.y + size_y // 2, text=self.label, fill="blue", font=("Arial", 12))

        # ì ì˜ ì²´ë ¥ í‘œì‹œ í…ìŠ¤íŠ¸ (ì ì˜ ìœ„ìª½ì— í‘œì‹œ)
        self.hp_text = canvas.create_text(self.x + size_x // 2, self.y - 10, text=str(self.hp), fill="red", font=("Arial", 10))

    def step(self):  # ìŠ¤í… í•¨ìˆ˜
        if self.coolt < self.cool: 
            self.coolt += 1  # ì¿¨íƒ€ì„ ê°ì†Œ
        if self.hp <= 0:  # HP <= 0ì¼ì‹œ ì œê±°
            global score
            self.destroy()
            enemyObjects.discard(self)
            score += self.mhp
        else:
            # ì²´ë ¥ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (ì ì˜ ìœ„ìª½ì— ìœ„ì¹˜)
            canvas.coords(self.hp_text, canvas.coords(self.canvas_id)[0] + self.size_x // 2, canvas.coords(self.canvas_id)[1] - 10)
            canvas.itemconfig(self.hp_text, text=str(self.hp))  # ì²´ë ¥ ì—…ë°ì´íŠ¸

            # ì¤‘ì•™ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ ("ê³¼ì œ" ë˜ëŠ” "ìˆ˜ì—…"ì„ ì ì˜ ì¤‘ì•™ì— í‘œì‹œ)
            canvas.coords(self.label_id, canvas.coords(self.canvas_id)[0] + self.size_x // 2, canvas.coords(self.canvas_id)[1] + self.size_y // 2)

    def destroy(self):
        super().destroy()
        # ì ì´ íŒŒê´´ë  ë•Œ í…ìŠ¤íŠ¸ë“¤ë„ í•¨ê»˜ ì œê±°
        canvas.delete(self.hp_text)
        canvas.delete(self.label_id)



class object_attack(element):  # attack ì˜¤ë¸Œì íŠ¸
    def __init__(self, x, y, size_x, size_y, color, livetime):
        super().__init__(x, y, 4, 4, color)  # ìƒì†
        self.livetime, self.fortime = 60, 0  # ë™ì‘ ì‹œê°„ (ì§€ì† ì‹œê°„ 60ìœ¼ë¡œ ì„¤ì •)

    def step(self):  # ìŠ¤í… í•¨ìˆ˜
        for obj_s in enemyObjects:
            if self.collision(obj_s):  # ì¶©ëŒ ì‹œ
                obj_s.hp -= 20
                self.destroy()
                break
        if self.livetime <= self.fortime:  # ì§€ì†ì‹œê°„ ì´ˆê³¼ ì‹œ íŒŒê´´
            self.destroy()
        self.fortime += 1


class object_enemyAttack(element):  # enemyAttack ì˜¤ë¸Œì íŠ¸
    def __init__(self, x, y, size_x, size_y, color, livetime, obj_main, damage):
        super().__init__(x, y, 8, 8, color)  # ì  ì´ì•Œ í¬ê¸°ë¥¼ 8x8ìœ¼ë¡œ ì„¤ì •
        self.livetime, self.fortime = livetime, 0  # ë™ì‘ ì‹œê°„
        self.obj_main = obj_main  # obj_main ë°›ê¸°
        self.damage = damage  # ë°ë¯¸ì§€

    def step(self):  # ìŠ¤í… í•¨ìˆ˜
        if self.obj_main in objects:  # ì¶©ëŒ ì‹œ
            if self.collision(self.obj_main):
                self.obj_main.hp -= self.damage
                self.destroy()
        if self.livetime <= self.fortime:  # ì§€ì†ì‹œê°„ ì´ˆê³¼ ì‹œ íŒŒê´´
            self.destroy()
        self.fortime += 1

    def move(self):
        # ì  ì´ì•Œ ì†ë„ë¥¼ ëŠë¦¬ê²Œ í•˜ê¸° ìœ„í•´ ì†ë„ë¥¼ ì¤„ì„
        x_value, y_value = self.x_accel * 0.5, self.y_accel * 0.5  # ì†ë„ë¥¼ ì ˆë°˜ìœ¼ë¡œ ì¤„ì„
        coords = canvas.coords(self.canvas_id)
        canvas.move(self.canvas_id, x_value, y_value)


Game()
```

---

## 1. ë‚´ê°€ í–ˆë˜ ì£¼ìš” ì‘ì—…ë“¤  

ì œê°€ ë§¡ì•˜ë˜ ì£¼ìš” ì‘ì—…ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

### ğŸ”« **ìë™ ë°œì‚¬ ì‹œìŠ¤í…œ êµ¬í˜„**  
ì²˜ìŒì—” ë§ˆìš°ìŠ¤ë¥¼ ëˆŒëŸ¬ì•¼ë§Œ ì´ì•Œì´ ë‚˜ê°€ëŠ” ë°©ì‹ì´ì—ˆìŠµë‹ˆë‹¤.  
ê·¼ë° ì˜¤ë˜ í”Œë ˆì´í•˜ê¸°ì—” ì¢€ í˜ë“¤ë”ë¼ê³ ìš”.  
ê·¸ë˜ì„œ **ìë™ ë°œì‚¬ ì‹œìŠ¤í…œ**ì„ êµ¬í˜„ì„ ë§¡ì•˜ìŠµë‹ˆë‹¤.

- **ì¿¨íƒ€ì„ ì‹œìŠ¤í…œ** ë„ì…  
  ì´ì•Œ ë°œì‚¬ëŠ” ì¼ì • ì‹œê°„ ê°„ê²©ìœ¼ë¡œ ìë™ìœ¼ë¡œ ë‚˜ê°‘ë‹ˆë‹¤.
- **ë°œì‚¬ ë°©í–¥ ì„¤ì •**  
  íˆ¬ì‚¬ì²´ëŠ” ë§ˆìš°ìŠ¤ ì»¤ì„œë¥¼ í–¥í•´ ë°œì‚¬ë©ë‹ˆë‹¤.

**ì½”ë“œ ì¼ë¶€ (ìë™ ë°œì‚¬ ë¶€ë¶„)**
```python
if obj_main.coolt == obj_main.cool:
    obj_attack = object_attack(í”Œë ˆì´ì–´ ì¢Œí‘œ ë° ë§ˆìš°ìŠ¤ ë°©í–¥ ê³„ì‚°...)
    obj_main.coolt = 0  # ì¿¨íƒ€ì„ ì´ˆê¸°í™”
```

ê°„ë‹¨í•´ ë³´ì´ì£ ? í•˜ì§€ë§Œ... ì§„ì§œ ë””ë²„ê¹…í•˜ëŠë¼ ê³ ìƒ ì¢€ í–ˆìŠµë‹ˆë‹¤. ğŸ˜­

---

### ğŸ“ **ì§§ì€ ìŠ¤í† ë¦¬ ì¶”ê°€**  
ì‚¬ì‹¤ì€ êµ¬êµ¬ì ˆì ˆ ì“¸ë ¤ê³  í–ˆëŠ”ë° ë§‰ìƒ.. ë„ˆë¬´ ì˜¤ê¸€ê±°ë ¤ì„œ ë§‰íŒì— ë°”ê¿¨ìŠµë‹ˆë‹¤ ã…ã…..  
ê²Œì„ì„ ì‹¤í–‰í•˜ê²Œ ë˜ë©´ ë°”ë¡œ ë‚˜ì˜¤ëŠ” í˜•ì‹ì´ê³  ë‚˜ì¤‘ì— ìŠ¤í‚µ ë²„íŠ¼ë„ ë§Œë“¤ê³  ì‹¶ë„¤ìš” ã…‡.ã…‡

- **ìŠ¤í† ë¦¬ ë‚´ìš©:**  
  *"A í•™ì ìœ¼ë¡œ í•™ê¸°ë¥¼ ë§ˆë¬´ë¦¬í•  ìˆ˜ ìˆê²Œ ë„ì™€ì¤˜!"*  

ê²Œì„ ì‹¤í–‰ ì´ˆë°˜ì— ì ê¹ ë‚˜ì˜µë‹ˆë‹¤.

---

### ğŸ“„ **Readme.md ì‘ì„±**  
ë§ˆì§€ë§‰ì€ ì‚¬ì†Œí•œ ê±°ì¼ ìˆ˜ë„ ìˆê³ .. ì•„ë‹ ìˆ˜ë„ ìˆê³  ì–´ì©Œë©´ ì œì¼ ì¤‘ìš”í•œ ë¶€ë¶„ì¼ ìˆ˜ë„ ìˆëŠ”ë°ìš”  
ì œê°€ ì‘ì„±í•œ ë‚´ìš©ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤. ğŸ’¨

- **ì‘ì„± ë‚´ìš©**  
  - ê²Œì„ ì†Œê°œ  
  - ì„¤ì¹˜ ë° ì‹¤í–‰ ë°©ë²•  
  - ì£¼ìš” ê¸°ëŠ¥ ì„¤ëª… 
  - ë²„ì „ ê´€ë¦¬ 

ì‚¬ì‹¤ ì²˜ìŒì—” ë­˜ ì¨ì•¼ í• ì§€ ëª°ë¼ì„œ ì—„ì²­ í—¤ë§¸ëŠ”ë°, êµìˆ˜ë‹˜ ê°€ì´ë“œë¼ì¸ ë•ë¶„ì— ìˆ˜ì›”í–ˆìŠµë‹ˆë‹¹

ì´ ì´ì™¸ì—ë„ ì½”ë“œ ê°œì„  ë“±ì´ ìˆì§€ë§Œ ë„ˆë¬´ ì‚¬ì†Œí•œ ê²ƒë“¤ì´ë¼ ë„£ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤ (__)

---

## 2. ì–´ë ¤ì› ë˜ ì   

ì´ë²ˆ í”„ë¡œì íŠ¸ì—ì„œ íŠ¹íˆ í˜ë“¤ì—ˆë˜ ë‘ ê°€ì§€ë¥¼ ê¼½ì•„ë³¼ê²Œìš”.  

### 1ï¸âƒ£ GitHub ì‚¬ìš© ë¯¸ìˆ™  
íŒ€ì›ë“¤ ëŒ€ë¶€ë¶„ì´ GitHubë¥¼ ì²˜ìŒ ì‚¬ìš©í•´ ë´¤ê¸° ë•Œë¬¸ì—, ì´ˆê¸°ì—ëŠ” ì»¤ë°‹ ë©”ì‹œì§€ ì‘ì„±, ë¸Œëœì¹˜ ê´€ë¦¬, Pull Request(PR) ì‘ì—… ë“±ì´ ì„œíˆ´ë €ìŠµë‹ˆë‹¤.  
ì‚¬ì‹¤ ì–´ì©” ìˆ˜ ì—†ëŠ” ë¶€ë¶„ì´ë¼ê³  ìƒê°í•´ìš”. ì™œëƒë©´ gitì„ ë°°ìš°ê¸° ìœ„í•´ ê°•ì˜ë¥¼ ë“£ëŠ” ê±°ê¸°ë„ í•˜ê³  ì´ˆë³´ìë“¤ë¼ë¦¬ ìœ¼ìŒ° ìœ¼ìŒ° í•˜ëŠ” ê±°ë‹ˆê¹Œìš”  


### 2ï¸âƒ£ ì „ê³µ ì§€ì‹ ë¶€ì¡±  
ì €ëŠ” ì‚¬ì‹¤ ì œëŒ€ë¡œ ëœ ê²Œì„ ê°œë°œì´ ì²˜ìŒì´ë¼ pygameë„ ì²˜ìŒ ì„¤ì¹˜í•´ ë³´ê³  ì²˜ìŒ í•´ë³´ëŠ” ê²ƒë“¤ì´ ë§ì•˜ì–´ìš”. ë¬¼ë¡  ê²Œì„ ê°œë°œí•˜ëŠ” ê²ƒë„ ë§ì´ ì–´ë µê³ .. ã… ã…  ì˜¤ë¥˜ë„ ë§ì´ ë‚˜ê³  ì¶©ëŒë„ ë§ì´ ë‚˜ê³  (ìƒê°ë³´ë‹¤ ë§ì´ í˜ë“¤ì—ˆë„¤)  
í–ˆì§€ë§Œ ì§€ë‚˜ê³  ë³´ë©´ ê½¤ë‚˜ ì¶”ì–µì´ì—ˆë„¤ìš”.. 

---

## 3. í”„ë¡œì íŠ¸ ê´€ë¦¬ ë°©ë²•  

ì €í¬ëŠ” **GitHub Issues íƒ­**ì„ í™œìš©í•´ í”„ë¡œì íŠ¸ë¥¼ ê´€ë¦¬í–ˆì–´ìš”.(ì´ê²ƒ ë˜í•œ êµìˆ˜ë‹˜ í”¼ë“œë°±ì…ë‹ˆë‹¤)  

- ì‘ì—…ì„ ì„¸ë¶„í™”í•´ì„œ ê°ê° ì´ìŠˆë¡œ ë“±ë¡í•˜ê³  ë‹´ë‹¹ì ì§€ì •  
- ì™„ë£Œëœ ì‘ì—…ì€ Close!  
- ìì„¸í•œ ì§„í–‰ ê³¼ì •ì€ [GitHub Repository](https://github.com/SKHU-OSS-2024-2/pygame-bravo-shooting)ì—ì„œ í™•ì¸í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

---

ì´ë ‡ê²Œ ê¸´ í¬ìŠ¤íŒ… ëê¹Œì§€ ì½ì–´ì£¼ì…”ì„œ ì •ë§ ê°ì‚¬í•©ë‹ˆë‹¤! ğŸ¥°  
ì´ ê¸€ì´ ë‹¤ë¥¸ ë¶„ë“¤ê»˜ ì¡°ê¸ˆì´ë¼ë„ ë„ì›€ì´ ë˜ì—ˆìœ¼ë©´ ì¢‹ê² ì–´ìš”.  
ê·¸ëŸ¼ ë‹¤ë¥¸ í¬ìŠ¤íŒ…ì—ì„œ ë§Œë‚˜ìš”~! ì•ˆë‡½~ ğŸ‘‹
