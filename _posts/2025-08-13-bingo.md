---
layout: post
title: "백준 2578번 빙고 문제 풀이 (Python)"
date: 2025-08-10
categories: [backjoon]
author: eoyeon
pin: true
---

### 문제 요약
5x5 크기의 빙고판이 주어지고, 사회자가 부르는 숫자를 하나씩 지워나갑니다. 가로, 세로, 대각선 중 3개 이상의 빙고줄이 완성되는 순간, 그때까지 사회자가 부른 숫자의 개수를 구하는 문제입니다.

### 접근 방법
이 문제는 빙고판의 상태를 실시간으로 확인하는 **탐색(Search) 로직**을 구현하는 것이 핵심입니다.

빙고판과 사회자 번호 저장: 5x5 빙고판은 2차원 리스트로, 사회자가 부르는 25개의 숫자는 1차원 리스트로 저장했습니다.

숫자 지우기: 사회자가 부르는 숫자를 하나씩 꺼내 빙고판에서 같은 숫자를 찾아 0으로 바꿉니다. 이때, for 반복문을 사용하여 모든 칸을 탐색했습니다.

**빙고 확인 함수**: 빙고가 몇 개인지 확인하는 로직은 check_bingo라는 함수로 따로 만들었습니다. 이 함수는 가로, 세로, 두 대각선에 0이 5개 있는지 확인하고, 그 개수를 반환합니다.

**빙고가 3개 이상일 때**: 사회자가 부르는 숫자마다 check_bingo 함수를 호출하여 빙고 개수를 확인합니다. 빙고가 3개 이상이 되는 순간, 그때까지 부른 숫자의 개수를 출력하고 반복문을 종료합니다.

### 전체 코드 (Python)

```python
def check_bingo(board):
    bingo_count = 0

    # 가로줄 빙고 확인
    for row in board:
        if row.count(0) == 5:
            bingo_count += 1

    # 세로줄 빙고 확인
    for j in range(5):
        cnt = 0
        for i in range(5):
            if board[i][j] == 0:
                cnt += 1
        if cnt == 5:
            bingo_count += 1
    
    # 대각선 빙고 확인
    diag1_cnt = 0
    diag2_cnt = 0
    for i in range(5):
        if board[i][i] == 0:
            diag1_cnt += 1
        if board[i][4-i] == 0:
            diag2_cnt += 1
    
    if diag1_cnt == 5:
        bingo_count += 1
    if diag2_cnt == 5:
        bingo_count += 1

    return bingo_count


# 빙고판을 입력받습니다.
num = [list(map(int, input().split())) for _ in range(5)]

# 사회자가 부르는 숫자를 하나의 리스트에 저장합니다.
s_nums_list = []
for _ in range(5):
    s_nums_list.extend(list(map(int, input().split())))

# 사회자가 부르는 숫자를 하나씩 처리합니다.
for turn, call_num in enumerate(s_nums_list):
    # 빙고판에서 부른 숫자를 찾아 0으로 만듭니다.
    for i in range(5):
        for j in range(5):
            if num[i][j] == call_num:
                num[i][j] = 0
                
    # 빙고 개수를 확인하고 3개 이상이면 출력 후 종료
    if check_bingo(num) >= 3:
        print(turn + 1)
        break
```