[
  
  {
    "title": "백준 2635번 수 이어가기 문제 풀이 (Python)",
    "url": "/posts/%EB%B0%B1%EC%A4%80-2635-test/",
    "categories": "baekjoon",
    "tags": "",
    "date": "2025-08-09 11:15:00 +0900",
    





    
    "snippet": "문제 요약주어진 양의 정수 N으로 시작하여, 두 번째 수부터는 앞의 두 수의 차를 이용해 새로운 수를 만드는 수열이 있습니다. 수열의 마지막 수가 음수가 되기 전까지 수열을 이어갈 때, 가장 긴 수열을 만들 수 있는 경우를 찾아야 합니다.접근 방법이 문제의 핵심은 첫 번째 수 N 다음으로 오는 두 번째 수가 무엇이냐에 따라 수열의 길이가 달라진다는 점...",
    "content": "문제 요약주어진 양의 정수 N으로 시작하여, 두 번째 수부터는 앞의 두 수의 차를 이용해 새로운 수를 만드는 수열이 있습니다. 수열의 마지막 수가 음수가 되기 전까지 수열을 이어갈 때, 가장 긴 수열을 만들 수 있는 경우를 찾아야 합니다.접근 방법이 문제의 핵심은 첫 번째 수 N 다음으로 오는 두 번째 수가 무엇이냐에 따라 수열의 길이가 달라진다는 점입니다.따라서 두 번째 수를 1부터 N까지 모두 시도해보는 완전 탐색(Brute Force) 방식을 사용했습니다.  두 번째 수 i를 1부터 N까지 반복하면서 수열을 만들고, 그중 가장 긴 수열을 찾습니다.  각 수열이 완성되면 기존에 저장해 둔 가장 긴 수열과 길이를 비교해 갱신합니다.  모든 경우를 확인한 후, 가장 길었던 수열의 길이와 수열을 출력합니다.전체 코드 (Python)```pythonn = int(input())max_l = 0max_num = []for i in range(1, n+1):    numbers = [n, i]while numbers[-1] &gt;= 0:    numbers.append(numbers[-2] - numbers[-1])numbers.pop()if max_l &lt; len(numbers):    max_l = len(numbers)    max_num = numbersprint(max_l)print(*max_num)"
  },
  
  {
    "title": "백준 2635번 수 이어가기 문제 풀이 (Python)",
    "url": "/posts/backjoon/",
    "categories": "baekjoon",
    "tags": "",
    "date": "2025-08-09 10:28:00 +0900",
    





    
    "snippet": "문제 요약주어진 양의 정수 N으로 시작하여, 두 번째 수부터는 앞의 두 수의 차를 이용해 새로운 수를 만드는 수열이 있습니다. 수열의 마지막 수가 음수가 되기 전까지 수열을 이어갈 때, 가장 긴 수열을 만들 수 있는 경우를 찾아야 합니다.접근 방법이 문제의 핵심은 첫 번째 수 N 다음으로 오는 두 번째 수가 무엇이냐에 따라 수열의 길이가 달라진다는 점...",
    "content": "문제 요약주어진 양의 정수 N으로 시작하여, 두 번째 수부터는 앞의 두 수의 차를 이용해 새로운 수를 만드는 수열이 있습니다. 수열의 마지막 수가 음수가 되기 전까지 수열을 이어갈 때, 가장 긴 수열을 만들 수 있는 경우를 찾아야 합니다.접근 방법이 문제의 핵심은 첫 번째 수 N 다음으로 오는 두 번째 수가 무엇이냐에 따라 수열의 길이가 달라진다는 점입니다.따라서 두 번째 수를 1부터 N까지 모두 시도해보는 완전 탐색(Brute Force) 방식을 사용했습니다.  두 번째 수 i를 1부터 N까지 반복하면서 수열을 만들고, 그중 가장 긴 수열을 찾습니다.  각 수열이 완성되면 기존에 저장해 둔 가장 긴 수열과 길이를 비교해 갱신합니다.  모든 경우를 확인한 후, 가장 길었던 수열의 길이와 수열을 출력합니다.전체 코드 (Python)```pythonn = int(input())max_l = 0max_num = []for i in range(1, n+1):    numbers = [n, i]while numbers[-1] &gt;= 0:    numbers.append(numbers[-2] - numbers[-1])numbers.pop()if max_l &lt; len(numbers):    max_l = len(numbers)    max_num = numbersprint(max_l)print(*max_num)"
  },
  
  {
    "title": "🎮 게임 개발기: 슈팅 게임 만들기",
    "url": "/posts/pygame/",
    "categories": "opensource study",
    "tags": "",
    "date": "2024-12-03 00:00:00 +0900",
    





    
    "snippet": "🎮 게임 개발기: “Shooting Game” 제작기2024학년 2학기 오픈소스 SW 개발 강의 중에 게임을 하나 만드는 과제가 있었는데요,이번 포스팅에서는 그 과정을 소개해 드릴까 해요. OwO!!0. 게임 소개일단 슈팅 게임을 만들기로 한 이유부터 말씀드릴게요.다른 장르에 비해 활동성이 높고, 수정하거나 추가할 수 있는 부분이 많아 보였기 때문입니...",
    "content": "🎮 게임 개발기: “Shooting Game” 제작기2024학년 2학기 오픈소스 SW 개발 강의 중에 게임을 하나 만드는 과제가 있었는데요,이번 포스팅에서는 그 과정을 소개해 드릴까 해요. OwO!!0. 게임 소개일단 슈팅 게임을 만들기로 한 이유부터 말씀드릴게요.다른 장르에 비해 활동성이 높고, 수정하거나 추가할 수 있는 부분이 많아 보였기 때문입니다..구글과 깃허브를 통하여 여러 코드를 찾아보다가… 슈팅게임의 한 코드로 결정을 했습니다 !기반 코드from tkinter import *import timeimport mathimport randomimport syswindow = Tk()window.title(\"종강을 향해 쏴라!\")  # 게임 이름window.resizable(0, 0)canvas = Canvas(window, width=640, height=640, bg=\"White\")  # 창 생성objects, enemyObjects, score = set(), set(), 0  # 오브젝트 세트, 점수 선언class Game:    def __init__(self):        global objects, enemyObjects, score        self.keys = set()  # 버튼 세트 생성        self.mx, self.my = 0, 0  # 마우스 좌표 초기화        self.runtime, self.spontime = 0, 300  # 런타임, 스폰타임        self.hp_before, self.score_before = 0, 0  # 갱신용 지역변수        self.enemyvalue = [[50, \"skyblue\"], [30, \"gray\"], [15, \"brown\"], [10, \"black\"]]  # 적 정보        window.bind(\"&lt;KeyPress&gt;\", self.keyPressHandler)  # 키보드 입력 처리        window.bind(\"&lt;KeyRelease&gt;\", self.keyReleaseHandler)  # 키보드 입력 해제 처리        canvas.bind(\"&lt;Motion&gt;\", self.mouseMove)  # 마우스 이동 추적        canvas.pack()        canvas.create_text(320, 60, text=\"😕종강을 향해 쏴라!🔫\", fill=\"Black\", font=(\"둥근모꼴\", 28))  # 설명        canvas.create_rectangle(100, 200, 135, 235, fill=\"lightgreen\", outline=\"Black\");        canvas.create_text(117, 217, text=\"A\", fill=\"Black\", font=(\"둥근모꼴\", 16))        canvas.create_rectangle(143, 200, 178, 235, fill=\"lightgreen\", outline=\"Black\");        canvas.create_text(160, 217, text=\"S\", fill=\"Black\", font=(\"둥근모꼴\", 16))        canvas.create_rectangle(186, 200, 221, 235, fill=\"lightgreen\", outline=\"Black\");        canvas.create_text(203, 217, text=\"D\", fill=\"Black\", font=(\"둥근모꼴\", 16))        canvas.create_rectangle(143, 157, 178, 192, fill=\"lightgreen\", outline=\"Black\");        canvas.create_text(160, 174, text=\"W\", fill=\"Black\", font=(\"둥근모꼴\", 16))        canvas.create_text(160, 270, text=\"&lt; 플레이어(학생) &gt;\", fill=\"Black\", font=(\"둥근모꼴\", 12))        canvas.create_rectangle(450, 157, 510, 235, outline=\"Black\");        canvas.create_line(480, 187, 510, 187, fill=\"Black\");        canvas.create_rectangle(450, 157, 480, 187, fill=\"lightblue\", outline=\"white\")        canvas.create_text(480, 270, text=\"&lt; 적 &gt;\", fill=\"Black\", font=(\"둥근모꼴\", 12))        canvas.create_text(300, 400, text=\"    공격해오는 과제들을 피해 죽이는 게임입니다!\\n\\n    시간이 지날수록 과제가 더 강해집니다! \", fill=\"slategray\",                          font=(\"둥근모꼴\", 12))        canvas.create_text(300, 400, text=\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n     응용SW개발 | [bravo] | 이수민, 김어연, 김우리, 안우혁\", fill=\"cornflowerblue\",                          font=(\"둥근모꼴\", 10))        self.textblinker()  # 시작 대기        # 게임 시작 대기 화면        self.textblinker()        # 캐릭터(플레이어) 생성        obj_main = object_main(316, 316, 8, 8, \"purple\")  # 플레이어 객체 생성        # 점수와 HP 표시        score_view = canvas.create_text(540, 15, text=\"SCORE: \" + str(score), fill=\"Black\", font=(\"Arial\", 16))        canvas.create_rectangle(5, 5, 420, 25, fill=\"White\")  # HP바 바탕 드로우        hpbar = canvas.create_rectangle(5, 5, 420, 25, fill=\"White\", width=0)        hptext = canvas.create_text(200, 15, text=\"HP: (\" + str(obj_main.hp) + \" / 1000)\", font=(\"Arial\", 8))        # 게임 메인 루프        while obj_main in objects:            for key in self.keys:                if key == ord('A') and obj_main.x_accel &gt; -3: obj_main.x_accel -= 1  # A                if key == ord('D') and obj_main.x_accel &lt; 3: obj_main.x_accel += 1  # D                if key == ord('W') and obj_main.y_accel &gt; -3: obj_main.y_accel -= 1  # W                if key == ord('S') and obj_main.y_accel &lt; 3: obj_main.y_accel += 1  # S            # 마우스 클릭 없이 자동으로 투사체 발사            if obj_main.coolt == obj_main.cool:                obj_attack = object_attack(canvas.coords(obj_main.canvas_id)[0] + 8,                                           canvas.coords(obj_main.canvas_id)[1] + 8, 3, 3, \"purple\", 120)                obj_attack.x_accel, obj_attack.y_accel = self.movePoint(                    canvas.coords(obj_attack.canvas_id)[0] + 10,                    canvas.coords(obj_attack.canvas_id)[1] + 10,                    self.mx, self.my, 25)  # 마우스 좌표로 투사체 이동                obj_main.coolt = 0  # 쿨타임 초기화            if self.hp_before != obj_main.hp:  # hp 갱신                   canvas.delete(hpbar);                   canvas.delete(hptext)                   hpbar = canvas.create_rectangle(5, 5, 420 * obj_main.hp / obj_main.mhp, 25, fill=\"pink\",                                                   width=0)                   hptext = canvas.create_text(200, 15, text=\"HP: (\" + str(obj_main.hp) + \" / 1000)\",                                               font=(\"둥근모꼴\", 12))                   self.hp_before = obj_main.hp            if self.score_before != score:  # 점수 갱신                   canvas.itemconfig(score_view, text=\"SCORE: \" + str(score))                   self.score_before = score            self.runtime += 1  # 런타임 증가            if len(enemyObjects) &lt; 25:  # 적 개체 수 제한                if self.runtime % self.spontime == 0:  # 100 루프마다 적 생성                    for i in range(4):                        if self.runtime % (self.spontime * (i + 1) ** 2) == 0: obj_enemy = object_enemy(                            random.choice([-100, 740]) + random.randrange(-50, 50),                            random.choice([-100, 740]) + random.randrange(-50, 50), self.enemyvalue[i][0],                            self.enemyvalue[i][0], self.enemyvalue[i][1], obj_main, i)  # enemy 오브젝트 스폰                    self.spontime = max([random.randrange(self.spontime - 2, self.spontime), 50])  # 스폰시간 초기화                for obj in enemyObjects.copy():                    degree = math.atan2(canvas.coords(obj_main.canvas_id)[0] - canvas.coords(obj.canvas_id)[0],                                        canvas.coords(obj_main.canvas_id)[1] - canvas.coords(obj.canvas_id)[1])                    obj.x_accel, obj.y_accel = -obj.enemy_stat[obj.enemy_type][1] * math.cos(degree), 5 * math.sin(                        degree)  # main 오브젝트 공전                    if obj.coolt == obj.cool:                        obj_enemyAttack = object_enemyAttack(                            canvas.coords(obj.canvas_id)[0] + (obj.size_x - obj.enemy_stat[obj.enemy_type][3]) / 2,                            canvas.coords(obj.canvas_id)[1] + (obj.size_y - obj.enemy_stat[obj.enemy_type][3]) / 2,                            obj.enemy_stat[obj.enemy_type][3], obj.enemy_stat[obj.enemy_type][3], obj.color, 100,                            obj_main, obj.enemy_stat[obj.enemy_type][5])  # obj_enemyAttack 생성                        obj_enemyAttack.x_accel, obj_enemyAttack.y_accel = self.movePoint(                            canvas.coords(obj_enemyAttack.canvas_id)[0] + random.randrange(-5, 5),                            canvas.coords(obj_enemyAttack.canvas_id)[1] + random.randrange(-5, 5),                            canvas.coords(obj_main.canvas_id)[0] + 10, canvas.coords(obj_main.canvas_id)[1] + 10,                            obj.enemy_stat[obj.enemy_type][4])                        obj.coolt = 0            for obj in objects.copy():                obj.move();                obj.step()            if not obj_main in objects:                canvas.delete(\"all\");                break            window.update(); # ui 변경사항 즉시 저장            time.sleep(0.01)  # 0.01초 만큼 sleep        canvas.create_text(320, 260, text=\"과제들을 이겨내지 못했습니다...\", fill=\"Black\", font=(\"둥근모꼴\", 38));        canvas.create_text(320, 370, text=str(score) + \" 점\", fill=\"Black\", font=(\"둥근모꼴\", 28))        self.textblinker(\"종강 실패\")  # 종료 대기        sys.exit(1)    def keyPressHandler(self, event):  # 버튼 세트에 버튼추가       self.keys.add(event.keycode)    def keyReleaseHandler(self, event):  # 버튼 세트에 버튼 제거       if event.keycode in self.keys: self.keys.remove(event.keycode)    def mouseMove(self, event):        self.mx, self.my = event.x, event.y  # 마우스 이동 시 좌표 갱신    def movePoint(self, x1, y1, x2, y2, spd):  # 해당 좌표로 이동       return (x2 - x1) * spd / math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2), (y2 - y1) * spd / math.sqrt(           (x2 - x1) ** 2 + (y2 - y1) ** 2)    def textblinker(self, sentance=\"start\"):  # 대기 텍스트        menuToggle = True;        blinkerText = canvas.create_text(320, 580, text=\"&lt; Please pless spacebar to \" + sentance + \". &gt;\", fill=\"red\",                                        font=(\"둥근모꼴\", 12))  # 깜박이 canvas 생성        while (True):  # 대기            self.runtime += 1            for key in self.keys:  # spacebar 누를시 다음으로                if key == 32:                    canvas.delete(\"all\");                    return            if self.runtime % 60 == 0:                if menuToggle == True:                    canvas.itemconfig(blinkerText, text=\"\");                    menuToggle = False                else:                    canvas.itemconfig(blinkerText, text=\"&lt; Please pless spacebar to \" + sentance + \". &gt;\");                    menuToggle = True            window.update();            time.sleep(0.01)# 오브젝트 클래스 정의class element:    def   collision(self, obj):        self_coords = canvas.coords(self.canvas_id)        obj_coords = canvas.coords(obj.canvas_id)        # 충돌 여부를 판단하는 조건        return (self_coords[0] &lt; obj_coords[2] and                self_coords[2] &gt; obj_coords[0] and                self_coords[1] &lt; obj_coords[3] and                self_coords[3] &gt; obj_coords[1])    def __init__(self, x, y, size_x, size_y, color):        self.x, self.y = x, y  # 생성 위치        self.size_x, self.size_y = size_x, size_y  # 크기        self.color = color  # 색        self.x_accel, self.y_accel = 0, 0  # 가속도        objects.add(self)  # 오브젝트 세트에 자신 등록        self.canvas_id = canvas.create_rectangle(x, y, x + self.size_x, y + self.size_y, fill=self.color,                                                width=0)  # 캠버스 추가    def destroy(self):        # 객체가 이미 canvas에서 제거되었는지 확인 후 제거        if hasattr(self, 'canvas_id') and self.canvas_id is not None:            objects.discard(self)  # 오브젝트 세트에서 제거            canvas.delete(self.canvas_id)  # 캠버스에서 제거            self.canvas_id = None  # 더 이상 유효하지 않도록 설정            del self    def move(self):        # self.canvas_id가 유효한지 확인 후 처리        if hasattr(self, 'canvas_id') and self.canvas_id is not None:            x_value, y_value = self.x_accel, self.y_accel            if x_value != 0 or y_value != 0:                coords = canvas.coords(self.canvas_id)                if coords:                    if coords[0] + x_value &lt; 0: x_value, self.x_accel = -coords[0], -self.x_accel                    if coords[1] + y_value &lt; 30: y_value, self.y_accel = 30 - coords[1], -self.y_accel                    if coords[2] + x_value &gt; 640: x_value, self.x_accel = 640 - coords[2], -self.x_accel                    if coords[3] + y_value &gt; 640: y_value, self.y_accel = 640 - coords[3], -self.y_accel                    canvas.move(self.canvas_id, x_value, y_value)                    self.x_accel, self.y_accel = self.x_accel * 0.98, self.y_accel * 0.98    def step(self):        pass  # 빈 함수로 정의 (다른 객체에서 상속하여 사용)class object_main(element):  # main 오브젝트    def __init__(self, x, y, size_x, size_y, color):        super().__init__(x, y, 16, 16, color)  # 상속        self.mhp, self.hp = 1000, 1000  # 체력        self.cool, self.coolt = 10, 0  # 쿨타임    def step(self):  # 스텝 함수        if self.coolt &lt; self.cool:            self.coolt += 1  # 쿨타임 감소        if self.hp &lt;= 0:            self.destroy()  # HP &lt;= 0 일시 제거class object_enemy(element):  # enemy 오브젝트    def __init__(self, x, y, size_x, size_y, color, obj_main, enemy_type):        super().__init__(x, y, size_x, size_y, color)  # 상속        self.enemy_stat = [[100, 2, 30, 3, 10, 20], [500, 1, 75, 5, 11, 30], [150, 3, 10, 3, 15, 50],                           [2500, 1, 30, 6, 12, 80]]  # HP, 속도, 공격속도, 투사체 크기, 투사체 속도, 데미지        self.enemy_type = enemy_type        self.mhp = self.enemy_stat[self.enemy_type][0]        self.hp = self.mhp  # 체력        self.cool, self.coolt = self.enemy_stat[self.enemy_type][2], 0  # 쿨타임        enemyObjects.add(self)  # enemy 오브젝트 세트에 자신 등록        self.obj_main = obj_main  # obj_main 오브젝트 받기        # 적의 중앙에 표시할 \"과제\" 또는 \"수업\" 텍스트 생성        self.label = \"과제\" if random.random() &lt; 0.5 else \"수업\"        self.label_id = canvas.create_text(self.x + size_x // 2, self.y + size_y // 2, text=self.label, fill=\"blue\", font=(\"Arial\", 12))        # 적의 체력 표시 텍스트 (적의 위쪽에 표시)        self.hp_text = canvas.create_text(self.x + size_x // 2, self.y - 10, text=str(self.hp), fill=\"red\", font=(\"Arial\", 10))    def step(self):  # 스텝 함수        if self.coolt &lt; self.cool:             self.coolt += 1  # 쿨타임 감소        if self.hp &lt;= 0:  # HP &lt;= 0일시 제거            global score            self.destroy()            enemyObjects.discard(self)            score += self.mhp        else:            # 체력 텍스트 업데이트 (적의 위쪽에 위치)            canvas.coords(self.hp_text, canvas.coords(self.canvas_id)[0] + self.size_x // 2, canvas.coords(self.canvas_id)[1] - 10)            canvas.itemconfig(self.hp_text, text=str(self.hp))  # 체력 업데이트            # 중앙 텍스트 업데이트 (\"과제\" 또는 \"수업\"을 적의 중앙에 표시)            canvas.coords(self.label_id, canvas.coords(self.canvas_id)[0] + self.size_x // 2, canvas.coords(self.canvas_id)[1] + self.size_y // 2)    def destroy(self):        super().destroy()        # 적이 파괴될 때 텍스트들도 함께 제거        canvas.delete(self.hp_text)        canvas.delete(self.label_id)class object_attack(element):  # attack 오브젝트    def __init__(self, x, y, size_x, size_y, color, livetime):        super().__init__(x, y, 4, 4, color)  # 상속        self.livetime, self.fortime = 60, 0  # 동작 시간 (지속 시간 60으로 설정)    def step(self):  # 스텝 함수        for obj_s in enemyObjects:            if self.collision(obj_s):  # 충돌 시                obj_s.hp -= 20                self.destroy()                break        if self.livetime &lt;= self.fortime:  # 지속시간 초과 시 파괴            self.destroy()        self.fortime += 1class object_enemyAttack(element):  # enemyAttack 오브젝트    def __init__(self, x, y, size_x, size_y, color, livetime, obj_main, damage):        super().__init__(x, y, 8, 8, color)  # 적 총알 크기를 8x8으로 설정        self.livetime, self.fortime = livetime, 0  # 동작 시간        self.obj_main = obj_main  # obj_main 받기        self.damage = damage  # 데미지    def step(self):  # 스텝 함수        if self.obj_main in objects:  # 충돌 시            if self.collision(self.obj_main):                self.obj_main.hp -= self.damage                self.destroy()        if self.livetime &lt;= self.fortime:  # 지속시간 초과 시 파괴            self.destroy()        self.fortime += 1    def move(self):        # 적 총알 속도를 느리게 하기 위해 속도를 줄임        x_value, y_value = self.x_accel * 0.5, self.y_accel * 0.5  # 속도를 절반으로 줄임        coords = canvas.coords(self.canvas_id)        canvas.move(self.canvas_id, x_value, y_value)Game()1. 내가 했던 주요 작업들제가 맡았던 주요 작업은 다음과 같습니다.🔫 자동 발사 시스템 구현처음엔 마우스를 눌러야만 총알이 나가는 방식이었습니다.근데 오래 플레이하기엔 좀 힘들더라고요.그래서 자동 발사 시스템을 구현을 맡았습니다.  쿨타임 시스템 도입총알 발사는 일정 시간 간격으로 자동으로 나갑니다.  발사 방향 설정투사체는 마우스 커서를 향해 발사됩니다.코드 일부 (자동 발사 부분)if obj_main.coolt == obj_main.cool:    obj_attack = object_attack(플레이어 좌표 및 마우스 방향 계산...)    obj_main.coolt = 0  # 쿨타임 초기화간단해 보이죠? 하지만… 진짜 디버깅하느라 고생 좀 했습니다. 😭📝 짧은 스토리 추가사실은 구구절절 쓸려고 했는데 막상.. 너무 오글거려서 막판에 바꿨습니다 ㅎㅎ..게임을 실행하게 되면 바로 나오는 형식이고 나중에 스킵 버튼도 만들고 싶네요 ㅇ.ㅇ  스토리 내용:“A 학점으로 학기를 마무리할 수 있게 도와줘!”게임 실행 초반에 잠깐 나옵니다.📄 Readme.md 작성마지막은 사소한 거일 수도 있고.. 아닐 수도 있고 어쩌면 제일 중요한 부분일 수도 있는데요제가 작성한 내용은 아래와 같습니다. 💨  작성 내용          게임 소개      설치 및 실행 방법      주요 기능 설명      버전 관리      사실 처음엔 뭘 써야 할지 몰라서 엄청 헤맸는데, 교수님 가이드라인 덕분에 수월했습니당이 이외에도 코드 개선 등이 있지만 너무 사소한 것들이라 넣지 않았습니다 (__)2. 어려웠던 점이번 프로젝트에서 특히 힘들었던 두 가지를 꼽아볼게요.1️⃣ GitHub 사용 미숙팀원들 대부분이 GitHub를 처음 사용해 봤기 때문에, 초기에는 커밋 메시지 작성, 브랜치 관리, Pull Request(PR) 작업 등이 서툴렀습니다.사실 어쩔 수 없는 부분이라고 생각해요. 왜냐면 git을 배우기 위해 강의를 듣는 거기도 하고 초보자들끼리 으쌰 으쌰 하는 거니까요2️⃣ 전공 지식 부족저는 사실 제대로 된 게임 개발이 처음이라 pygame도 처음 설치해 보고 처음 해보는 것들이 많았어요. 물론 게임 개발하는 것도 많이 어렵고.. ㅠㅠ 오류도 많이 나고 충돌도 많이 나고 (생각보다 많이 힘들었네)했지만 지나고 보면 꽤나 추억이었네요..3. 프로젝트 관리 방법저희는 GitHub Issues 탭을 활용해 프로젝트를 관리했어요.(이것 또한 교수님 피드백입니다)  작업을 세분화해서 각각 이슈로 등록하고 담당자 지정  완료된 작업은 Close!  자세한 진행 과정은 GitHub Repository에서 확인하실 수 있습니다.이렇게 긴 포스팅 끝까지 읽어주셔서 정말 감사합니다! 🥰이 글이 다른 분들께 조금이라도 도움이 되었으면 좋겠어요.그럼 다른 포스팅에서 만나요~! 안뇽~ 👋"
  },
  
  {
    "title": "애자일 학습 후기",
    "url": "/posts/Agile/",
    "categories": "opensource study",
    "tags": "",
    "date": "2024-12-02 00:00:00 +0900",
    





    
    "snippet": "애자일 학습 후기📝 애자일과의 첫 만남이번 학기에는 소프트웨어 개발 방법론 중 하나인 애자일(Agile)에 대해 배우게 되었다. 처음 애자일이라는 말을 들었을 때는 단순히 빠르고 효율적으로 개발하는 방법이라고만 생각했습니다.하지만 강의를 통해 애자일이 단순한 속도 중심의 개발 방식이 아니라, 협업, 소통, 그리고 변화에 대한 유연함을 강조하는 철학적 ...",
    "content": "애자일 학습 후기📝 애자일과의 첫 만남이번 학기에는 소프트웨어 개발 방법론 중 하나인 애자일(Agile)에 대해 배우게 되었다. 처음 애자일이라는 말을 들었을 때는 단순히 빠르고 효율적으로 개발하는 방법이라고만 생각했습니다.하지만 강의를 통해 애자일이 단순한 속도 중심의 개발 방식이 아니라, 협업, 소통, 그리고 변화에 대한 유연함을 강조하는 철학적 접근이라는 것을 알게 되었습니다. 특히, “계획을 따르기보다는 변화에 대응하라” 는 원칙이 가장 인상 깊었습니다.💡 애자일의 핵심 이해1. 폭포수 모델과 애자일의 차이애자일을 이해하기 위해 전통적인 폭포수 모델(Waterfall Model)과 비교해 보았습니다 !  폭포수 모델          단계별로 진행되며, 초기 계획과 설계가 매우 중요      중간에 요구사항이 변경되면 적용하기 어려움        애자일 모델          반복적이고 점진적인 개발 방식      지속적인 피드백을 통해 개선 가능      변화와 불확실성을 자연스럽게 수용      2. 애자일 선언문의 가르침애자일 선언문에서 제시하는 네 가지 핵심 가치는 단순히 개발 환경에서만 적용되는 것이 아니라, 다른 협업 활동에서도 유용하다고 생각했습니다.  개인과 상호작용 &gt; 프로세스와 도구          사람 간의 신뢰와 협력은 모든 성공의 기본이라는 점        작동하는 소프트웨어 &gt; 포괄적 문서화          결과물 자체보다는 그 과정에서 만들어지는 실질적인 가치를 중시해야 함        고객과의 협력 &gt; 계약 협상          고객뿐만 아니라 팀원 간의 소통도 중요하다는 점        변화에 대응 &gt; 계획 준수          변화는 피해야 할 문제가 아니라, 받아들여야 할 기회라는 점      🔑 애자일을 통해 기대되는 변화1. 더 나은 협업 환경애자일에서 강조하는 개인 간의 상호작용은 팀원들과 더 긴밀히 협력하는 데 큰 도움이 될 것 같습니다.앞으로의 팀 활동에서 서로의 진행 상황을 공유하고, 문제를 빠르게 해결하며, 더 나은 결과를 만들어낼 수 있을 것이라 기대합니다.2. 유연한 계획 수립애자일의 원칙을 적용한다면, 모든 것을 처음부터 완벽하게 계획하지 않더라도, 변화에 따라 유연하게 대응할 수 있는 팀 활동을 진행할 수 있을 것입니다.특히 짧은 주기의 피드백을 통해 팀의 목표에 더 효과적으로 다가갈 수 있을 것 같습니다.3. 지속적인 개선애자일의 반복적이고 점진적인 접근 방식은 팀의 강점을 극대화하고, 부족한 점을 개선할 기회를 제공합니다. 이러한 회고 과정은 팀의 성과를 꾸준히 높이는 데 중요한 역할을 할 것입니다.🌟 애자일이 남긴 교훈애자일은 단순히 소프트웨어 개발 방법론을 넘어, 앞으로의 다양한 활동에서 적용할 수 있는 철학과 교훈을 안겨주었습니다      변화는 기회이다.계획대로 진행되지 않아도 괜찮습니다. 중요한 것은 변화를 어떻게 받아들이고, 그 속에서 최선의 결과를 만들어내느냐는 것입니다.        협업과 소통이 핵심이다.프로젝트 성공의 열쇠는 팀원 간의 신뢰와 상호작용임을 다시 한번 깨달았습니다.        작은 성공이 큰 성과를 만든다.모든 것을 한 번에 해결하려 하기보다는, 작은 성공을 쌓아나가는 방식이 더 효과적이라는 것을 배웠습니다.  🎯 앞으로의 다짐애자일을 배우면서 변화와 소통의 중요성을 새삼 느꼈습니다. 이제는 변화가 두렵게 느껴지기보다는, 더 나은 방향으로 나아갈 수 있는 기회라고 생각하게 되었습니다.앞으로 팀 활동을 하게 된다면, 모든 팀원이 자유롭게 의견을 나누고, 각자의 역할을 존중하며 함께 성장할 수 있는 환경을 만들고 싶습니다. 처음부터 완벽할 필요는 없다는 애자일의 메시지가 마음에 와 닿았기에, 작은 시도와 개선을 통해 목표에 조금씩 가까워지는 팀워크를 경험하고 싶습니다 !포스팅 읽어주셔서 감사합니다 😚 ❗"
  },
  
  {
    "title": "Naver Search Advisor를 이용한 검색 엔진 노출 방법",
    "url": "/posts/naver/",
    "categories": "opensource study",
    "tags": "",
    "date": "2024-11-19 00:00:00 +0900",
    





    
    "snippet": "시작하기 전 . . . 🎀지난번에는 Google Search Console을 이용해 내 블로그 글이 검색에 노출되도록 설정하는 방법을 알려드렸는데요! 이번에는 네이버에서도 내 블로그를 검색할 수 있도록 등록하는 과정을 소개하려 합니다. 열심히 작성한 글들이 더 많은 사람들에게 보여지길 바라는 마음, 다들 같으시죠? 😎그럼, 시작해볼까요? 🎁블로그 구축...",
    "content": "시작하기 전 . . . 🎀지난번에는 Google Search Console을 이용해 내 블로그 글이 검색에 노출되도록 설정하는 방법을 알려드렸는데요! 이번에는 네이버에서도 내 블로그를 검색할 수 있도록 등록하는 과정을 소개하려 합니다. 열심히 작성한 글들이 더 많은 사람들에게 보여지길 바라는 마음, 다들 같으시죠? 😎그럼, 시작해볼까요? 🎁블로그 구축 포스팅 보러가기댓글 서비스 적용 포스팅 보러가기조회수 서비스 적용 방법 보러가기Google Search Console을 이용한 검색 노출 방법1. Naver Search Advisor 활용하기1.0 Naver Search Advisor 접속  Naver Search Advisor 사이트에 접속합니다.1.1 로그인  사용할 네이버 계정으로 로그인합니다.1.2 약관 동의  이용 약관에 동의한 뒤 “확인” 버튼을 클릭합니다.1.3 웹마스터 도구 사용하기  페이지 하단으로 스크롤하여 웹마스터 도구 사용하기를 클릭합니다.1.4 블로그 링크 등록  자신의 블로그 주소를 등록합니다.예: https://name.github.io1.5 소유권 확인      소유권 확인 방법 중 HTML 태그를 선택합니다.    저번에 구글에서 소유권 확인할 때 사용했던 코드와 비슷하죠?마찬가지로 확인은 좀 있다가 눌러주도록 합시다.  2. Visual Studio Code에서 작업하기이제 블로그 파일을 수정해 네이버 소유권 확인 태그를 추가하겠습니다.2.1 head.html 파일 수정  _includes/head.html 파일 열기          이번에는 _config.yml 파일을 수정하지 않는 이유는, SEO 플러그인이 네이버 메타태그를 지원하지 않기 때문입니다.        HTML 태그 추가                  그래도 방법은 비슷하니 content 다음에 써져있는 부분을 복사해서 ** 아랫부분**에 코드를 붙여 넣어주세요 💨                    2.2 변경사항 커밋 및 푸시파일 수정이 끝났다면 GitHub에 커밋하고 푸시합니다:git add .git commit -m \"Add meta tags for Naver verification\"git push3. 다시 Naver Search Advisor로 돌아가기3.1 소유 확인 버튼 클릭이제 네이버 웹사이트에서 확인 버튼을 클릭합니다.3.2 소유권 확인 완료  네이버에서 블로그 소유권이 확인되었다는 메시지가 뜹니다!4. 사이트맵 제출하기이제 사이트맵을 제출해 네이버가 내 블로그를 더 잘 이해할 수 있도록 도와줍시다.4.1 사이트맵 제출  요청 &gt; 사이트맵 제출 메뉴로 이동합니다.      사이트맵 파일 주소를 입력하고 제출하세요.    제출이 완료되면 아래와 같이 목록에 추가됩니다.결과?구글과 마찬가지로 naver에 검색이 되기 위해서는며칠정도 걸린다고 합니다 .. 😭 (내 글 내놔..)추가 .. !며칠 후에 네이버에 제 블로그 주소를 쳐보니 아주 잘 나왔습니다 !!  성공적이네요 ^-^b마치며블로그 구축부터 댓글 생성, 조회수 확인, 그리고 검색 엔진 노출까지…처음엔 복잡해 보였던 과정들이 차근차근 해보니 생각보다 어렵지 않았죠?제 글이 블로그를 관리하는 데 도움이 되었길 바라며, 더 유익한 정보를 들고 다시 돌아오겠습니다!안뇽 ~~ 🖐️"
  },
  
  {
    "title": "Google Search Console를 이용한 검색 엔진 노출 방법",
    "url": "/posts/google/",
    "categories": "opensource study",
    "tags": "",
    "date": "2024-11-19 00:00:00 +0900",
    





    
    "snippet": "시작하기전 . . . 🍊지난번에 goatCounter를 이용해서 조회수 서비스를 적용했었죠. 하지만 이 방법에는 치명적인 단점이 있었습니다! 바로 상대방이 내 블로그 주소를 모르는 이상 내 글을 볼 수 없다는 점이죠…. 이번에는 Google Search Console을 이용해 구글 검색에서도 블로그가 노출될 수 있도록 설정해보겠습니다.그럼, 시작해볼까...",
    "content": "시작하기전 . . . 🍊지난번에 goatCounter를 이용해서 조회수 서비스를 적용했었죠. 하지만 이 방법에는 치명적인 단점이 있었습니다! 바로 상대방이 내 블로그 주소를 모르는 이상 내 글을 볼 수 없다는 점이죠…. 이번에는 Google Search Console을 이용해 구글 검색에서도 블로그가 노출될 수 있도록 설정해보겠습니다.그럼, 시작해볼까요? 💎블로그 구축 포스팅 보러가기댓글 서비스 적용 포스팅 보러가기goatCounter를 이용해 조회수 서비스 적용하는 방법1. Google Search Console 사이트 이용      1.0 Google Search Console 사이트에 접속합니다.            1.1 시작하기 버튼을 클릭합니다.        1.2 사용할 구글 계정으로 로그인합니다.        1.3 URL 접두어 선택        1.4 자신의 블로그 링크를 입력해주세요예시: https://name.github.io        1.5 계속 버튼 클릭계속 버튼을 클릭하면 아래와 같은 화면이 나옵니다.    소유권 확인은 다음 방법 중 하나로 할 수 있는데요          HTML 파일      HTML 태그      Google 애널리틱스      Google 태그 관리      도메인 이름 공급업체        여기서는 HTML 태그 추가를 사용하겠습니다. ✨    1.6 다른 확인 방법 &gt; HTML 태그 &gt; 코드 복사코드를 복사한 후 확인 버튼은 누르지 말고 잠시 기다려주세요!2. Visual Studio Code 작업2.1 _config.yml 파일 수정하기  2.1.1 블로그 루트 디렉터리에 있는 _config.yml 파일 열기아까 복사한 코드 있죠?그 코드 중에서 content 다음에 써져있는 부분을 복사해서 코드를 수정해주세요 💨 &lt;meta name='google-site-verification' content='여기부분!!'&gt;# Site Verification Settingswebmaster_verifications:  google: \"코드\"  bing: # fill in your Bing verification code  alexa: # fill in your Alexa verification code  yandex: # fill in your Yandex verification code  baidu: # fill in your Baidu verification code  facebook: # fill in your Facebook verification code2.2 변경사항 커밋 및 푸시하기  모든 파일을 수정한 후 GitHub에 커밋하고 푸시해줍니다.git add .git commit -m \"Add meta tags for SEO\"git push3. Google Search Console 사이트 이용      3.1 확인 버튼 클릭아까 클릭하지 않았던 확인 버튼을 이제 클릭해봅니다.        3.2 소유권 확인이 화면이 떴다면 아주 잘 따라오고 계신 겁니다. 👍        3.3 속성으로 이동 버튼 클릭  4. 사이트 맵 이용      4.1 사이트 맵 접속하기자신의 GitHub 블로그 주소에 /sitemap.xml을 추가하여 사이트 맵에 접속해봅니다.예시: https://name.github.io/sitemap.xml        4.2 사이트 맵 제출하기사이트 맵이 잘 보인다면 Google Search Console에 속성을 등록합니다.    제출이 완료된 화면을 볼 수 있습니다. 😊  5. 사이트 맵 버그  5.1 가져올 수 없음 버그뿌듯한 마음으로 화면을 보았는데, 엥? 가져올 수 없음?알고 보니 화면상의 버그일 뿐이고 시간이 지나면 바뀐다고 하네요. 😢결과?원래 이게 시간이 좀 걸린다고 알고 있는데 구글에서 제 블로그명을 쳐본결과  아주 잘나오네요 (뿌듯) 🤤다음 포스팅이번 포스팅에서는 검색엔진을 Google에서만 설정했습니다. 다음에는 Naver에 제 글을 노출시키는 방법에 대해 알아보겠습니다. 설명이 더 필요한 부분이 있다면 댓글로 남겨주세요!"
  },
  
  {
    "title": "goatCounter를 이용해서 조회수 서비스 적용하는 방법",
    "url": "/posts/goatcounter/",
    "categories": "opensource study",
    "tags": "",
    "date": "2024-11-18 00:00:00 +0900",
    





    
    "snippet": "시작하기전 . . . 👻댓글 기능도 넣고 나니 이제 블로그다운 느낌이 점차 살아나는 것 같아 좋군요! 😎그런데 아직은 내가 쓴 글을 몇 명이 읽었는지, 정말 내 글이 읽히고 있는지 알 방법이 없네요.그래서 오늘은 바로 조회수 서비스를 적용하는 방법에 대해 포스팅해보려고 합니다.그럼, 시작해볼까요? 😊블로그 구축 포스팅 보러가기댓글 서비스 적용 포스팅 ...",
    "content": "시작하기전 . . . 👻댓글 기능도 넣고 나니 이제 블로그다운 느낌이 점차 살아나는 것 같아 좋군요! 😎그런데 아직은 내가 쓴 글을 몇 명이 읽었는지, 정말 내 글이 읽히고 있는지 알 방법이 없네요.그래서 오늘은 바로 조회수 서비스를 적용하는 방법에 대해 포스팅해보려고 합니다.그럼, 시작해볼까요? 😊블로그 구축 포스팅 보러가기댓글 서비스 적용 포스팅 보러가기1. goatcounter사이트 이용  1.0 goatcounter 사이트에 접속합니다.      1.1 sign up 버튼을 클릭합니다.        1.2 필요한 정보들을 입력합니다.          Code: goatcounter를 사용할 때의 개인 코드      Site domain: 내 블로그 주소 (ex: name.github.io)      Email address: 사용할 이메일 주소      Password: 사용할 비밀번호      Fill in 9 here: 9 입력        1.3 sign up 버튼 클릭  sign up을 완료하면 goatcounter 사이트가 생성됩니다!      1.4 우측 상단의 Settings 클릭        1.5 settings -&gt; Allow adding visitor counts on your website 항목 체크        1.6 save 버튼 클릭  2. Visual Studio Code 작업2.1 _config.yml 파일 수정하기  2.1.1 블로그의 루트 디렉터리에 있는 _config.yml 파일 열기  아래 내용을 수정합니다:analytics:  google:    id: # fill in your Google Analytics ID  goatcounter:    id: name  umami:    id: # fill in your Umami ID    domain: # fill in your Umami domain  matomo:    id: # fill in your Matomo ID    domain: # fill in your Matomo domain  cloudflare:    id: # fill in your Cloudflare Web Analytics token  fathom:    id: # fill in your Fathom Site ID      name에는 goatcounter 가입 시 입력했던 코드 값을 입력합니다.        2.1.2 provider 부분 수정하기아래 내용을 수정합니다.  pageviews:  provider: goatcounter  2.1.3 저장2.2 변경사항 커밋 및 푸시하기  모든 파일 수정 후 GitHub에 커밋하고 푸시합니다 !git add .git commit -m \"Add goatcounter\"git push이제 자신의 goatcounter 사이트에서 대시보드를 확인하면 조회수 통계를 볼 수 있습니다. 또한 블로그 포스팅 오른쪽에도 조회수가 표시됩니다!주의현재는 GitHub Pages 주소를 직접 입력해야만 블로그에 접근할 수 있습니다. 따라서 블로그 주소를 알고 있지 않은 사람은 조회할 수 없다는 한계가 있습니다. 😭다음 포스팅다음 포스팅에서는 Google 및 Naver 검색 엔진을 통해 블로그를 검색 가능하게 만드는 방법을 알려드리겠습니다! 그럼 안뇽 🖐🖐"
  },
  
  {
    "title": "댓글 서비스 적용하는 방법",
    "url": "/posts/comment/",
    "categories": "opensource study",
    "tags": "",
    "date": "2024-11-17 00:00:00 +0900",
    





    
    "snippet": "시작하기전 . . . 💌지난번에는 Git을 활용해 블로그를 직접 구축해보았는데요, 어떠셨나요? 아직 댓글 기능도 없고 조회수를 확인할 수 있는 곳도 없어서 다소 기본적인 형태의 블로그지만, 이번 포스팅에는 댓글 기능을 적용하는 방법에 대해 이야기해보려고 합니다. 그럼 시작해볼까요? 😊블로그 구축 포스팅 보러가기1. Utterances 설정하기  1.0...",
    "content": "시작하기전 . . . 💌지난번에는 Git을 활용해 블로그를 직접 구축해보았는데요, 어떠셨나요? 아직 댓글 기능도 없고 조회수를 확인할 수 있는 곳도 없어서 다소 기본적인 형태의 블로그지만, 이번 포스팅에는 댓글 기능을 적용하는 방법에 대해 이야기해보려고 합니다. 그럼 시작해볼까요? 😊블로그 구축 포스팅 보러가기1. Utterances 설정하기  1.0 Utterances 사이트에 접속합니다.      1.1 Configure 버튼을 선택합니다.     1.2 적용하고 싶은 repository를 Only select repositories 옵션에서 선택한 후 Save를 클릭합니다.      1.3 repo 입력란에 적용할 사이트의 GitHub 주소를 입력합니다. 예: name.github.io/name.github.io         1.4 Blog Post &lt;-&gt; Issue Mapping 옵션에서 Issue title contains Page Pathname을 선택합니다.     1.5 label (optional) 부분에 원하는 레이블 이름을 입력할 수 있는데, 댓글을 구분하기 위해 레이블을 설정하는 것이 좋아요1.5 레이블 생성하기  1.5.1 자신의 repository 페이지에서 Issues 탭으로 이동합니다.      1.5.2 Labels 버튼을 클릭합니다.     1.5.3 New Label에서 레이블 이름과 색상을 지정한 후 Create label 버튼을 클릭합니다.레이블이 만들어졌습니다! 💨2. Visual Studio Code 작업이제 블로그에 댓글 기능을 활성화하기 위해 GitHub Pages의 구성 파일과 레이아웃 파일을 수정하는 작업을 해볼겁니다 !2.1 _config.yml 파일 수정하기  블로그의 루트 디렉터리에 있는 _config.yml 파일을 열어 아래 내용을 수정합니다.comments:  provider: utterances  utterances:    repo : \"name/name.github.io\"    issue-term : pathname  name에는 자신의 GitHub 사용자 이름을 입력해 주세요.2.2 _layouts/post.html 파일 수정하기  댓글 기능을 활성화하려면 블로그 게시물의 HTML 레이아웃 파일인 _layouts/post.html 파일을 수정해야 합니다.  Utterances 설정 페이지에서 제공하는 코드를 복사한 후,post.html 파일의 하단에 붙여넣습니다. 2.3 변경사항 커밋 및 푸시하기  모든 파일 수정이 완료되었다면, 변경사항을 저장하고 GitHub에 커밋한 후 푸시합니다. 이제 고지가 보이네요 😚git add .git commit -m \"Add comments using Utterances\"git push이제 블로그 게시물에 댓글 기능이 잘 적용되었는지 한번 확인해 봅시다!블로그 포스팅 맨 밑을 확인해 보면 잘 적용이 되었네요 😎Utterances를 추천해 드리는 이유는 GitHub Issues를 활용해 댓글을 관리할 수 있어 관리가 편하고, 무엇보다 무료입니다이상으로 포스팅을 마치겠습니다다음에는 조회수 적용 방법에 대한 포스팅을 찾아뵐게요 ! 그럼 안뇽 🖐🖐"
  },
  
  {
    "title": "Github Page 기반 블로그 구축하기",
    "url": "/posts/first/",
    "categories": "opensource study",
    "tags": "",
    "date": "2024-11-11 00:00:00 +0900",
    





    
    "snippet": "블로그 구축을 시작하기전 . . . 🍀GitHub를 활용해 간단하게 나만의 블로그를 구축할 수 있다는 사실, 알고 계셨나요? Git을 배우고 싶거나, 자신만의 블로그를 만들어보고 싶은 분들께 추천드리는 실습입니다!. 그럼, 블로그 제작 가이드를 포스팅해볼게요 ☠블로그 제작, 이런 분들께 추천드려요!  Git의 기본 명령어(add, commit, pus...",
    "content": "블로그 구축을 시작하기전 . . . 🍀GitHub를 활용해 간단하게 나만의 블로그를 구축할 수 있다는 사실, 알고 계셨나요? Git을 배우고 싶거나, 자신만의 블로그를 만들어보고 싶은 분들께 추천드리는 실습입니다!. 그럼, 블로그 제작 가이드를 포스팅해볼게요 ☠블로그 제작, 이런 분들께 추천드려요!  Git의 기본 명령어(add, commit, push)를 사용할 줄 안다.  나만의 블로그를 가지고 싶다!  GitHub를 사용해본 적 있다!0. 사전 준비사항블로그를 구축하기 전에, 다음 준비 사항을 확인해 주세요. 📌  Windows 64bit  Git 설치  VS Code 설치  GitHub 가입1. Github Page 생성1-1. Repository 생성  github 로그인  프로필 사진 -&gt; Your repositories 선택  New 선택  github username이 name인 경우, repository name을 name.github.io로 설정  Public 체크  Add a README file 체크repository가 생성된게 보이시나요?1-2. Github Page 설정  생성한 리포지토리로 이동, 상단 Settings 클릭  좌측 Pages 클릭  Source를 Deploy from a branch로 설정  사이트 접속 확인을 해봅니다. (예시: https://name.github.io)1-3. VS Code 활용리포지토리 클론  VS Code 열기 » F1 키 입력 » git clone 검색 » Git: Clone 선택  리포지토리 주소 입력 » 클론할 위치 선택  이 때, 한글이 포함된 경로, D드라이브에 저장하지 않도록 주의합니다.로컬 변경사항 적용  클론한 리포지토리 열기 (README.md 파일 확인)          VS code 상단에 점 세개 클릭      파일 -&gt; 폴더 열기      아까 저장한 위치를 찾아서 열기        index.html 파일을 생성해서 아래의 내용을 복사해서 붙여넣어주세요&lt;html&gt;\t&lt;body&gt;\t\tHello! This is the first page!\t&lt;/body&gt;&lt;/html&gt;  좌측 Source Control 메뉴 선택  + 버튼을 클릭하여 변경사항 추가  커밋 메시지 입력, 커밋 &amp; 푸시  사이트 반영 확인을 해봅니다. (예시: https://name.github.io)2. 로컬 개발 환경 구축2-1. Ruby 설치  공식 홈페이지에서 최신버전 다운로드 (Ruby+Devkit x.y.z-1 (x64)) 및 설치  시작(윈도우 키)를 누르고 Start Command Prompt with Ruby 검색 후 실행      cd 명령어(리포지토리로 이동하는 명령어)로 리포지토리가 있는 위치로 이동    [예시] 자신의 리포지토리를 클론한 곳 주소를 적어주세요    cd C:\\Users\\name\\Documents\\name.github.io        jekyll, bundler, webrick 설치코드를 복사 붙여넣어주세요    gem install jekyll bundlergem install webrick        설치 확인    ruby -vjekyll -vbundler -v          설치가 완료 되었습니다!2-2. Jekyll 서버 구축마찬가지로 Start Command Prompt with Ruby 에서 입력해줍니다.  jekyll 생성    jekyll new ./ --force        bundle install    bundle install        jekyll 서버 실행    bundle exec jekyll serve        http://127.0.0.1:4000/ 또는 http://localhost:4000/ 페이지 에서 접속이 가능한지 확인해봅니다3. Jekyll 테마 적용3-0. 테마 선택  http://jekyllthemes.org  https://jekyllthemes.io/free  https://themes.jekyllrc.org  https://github.com/topics/jekyll-theme아무테마나 적용해도 상관없어요    3-1. chirpy 테마 적용    현재 제가 사용하고 있는 chirpy 테마 기준으로 설명해보겠습니다.    공식 홈페이지에서 압축파일 다운로드  압축을 해제한 뒤, 모든 파일과 폴더를 로컬 리포지토리로 복사(폴더째 옮기지말고 전체 복사해서 옮겨주세요)  bundle install    bundle install        jekyll 서버 실행    bundle exec jekyll serve        http://127.0.0.1:4000/ 또는 http://localhost:4000/ 접속 확인해봅니다  오류가 나지 않고 잘 실행된다면 모든 변경사항 커밋 및 푸시          git add      git commit -m \"메세지\"      git push        잘 푸쉬되었는지 리포지토리로가 확인해봅니다.3-2. Github Action 적용  원격 리포지토리의 상단 Settings 클릭  좌측 Pages 클릭  Source를 Github Actions로 설정  Configure 클릭  Commit changes... 클릭  로컬 리포지토리에서 pull3-3. Node.js 설치공식 홈페이지에서 최신버전 다운로드 및 설치  Ruby 프롬프트에서 아래 명령어 실행    npm install &amp;&amp; npm run build      3-4. 테마 상세 설정거의 다 왔습니다!  .gitignore 파일 하단 수정해줍니다.    # Misc# _sass/dist# assets/js/dist        _config.yml 파일 수정해줍니다.    timezone: Asia/Seoulurl: \"https://name.github.io\"github:  username: name        모든 변경사항 커밋 및 푸시  커밋 메시지 신경써주세요 (ex fix: add js files)  자신의 사이트로 들어가 반영 확인 (예시: https://name.github.io)사이트로 들어가 반영이 잘 되었다면 블로그 구축 성공입니다!댓글/조회수/검색 노출 블로그에 설정하고 싶다면 다른 포스팅을 참고해 주세요 😎에러가 나는 경우1. Ruby 설치 중 cd 디렉토리명 명령어가 작동하지 않을 경우  확인 사항: Clone한 저장 위치가 D드라이브에 있는지 확인합니다. 만약 D드라이브에 있다면 C드라이브로 옮겨주세요.2. 테마 상세 설정 중 커밋이 되지 않을 경우  해결 방법: 아래 명령어를 사용해 커밋합니다.    git commit --no-verify -m \"커밋 메세지\"        brew터미널인지 확인    터미널 상단의 이름이나 커서 앞에 기호가 $인지로 구분할 수 있습니다. 만약 brew터미널이 아니라면 brew터미널로 이동해야 합니다. 이동하는 방법은 1. Ruby설치에 작성되어있습니다    brew가 최신 버전이 아님    brew가 최신버전이 아니어서 오류가 뜰 수도 있습니다. 업데이트 해주면 됩니다.    brew update        Ruby가 최신 버전이 아님    Ruby가 최신 버전이 아니어서 오류가 뜰 수도 있습니다. 최신버전 확인 후 업데이트 해주면 됩니다.    rebenv install 버전      참고한 글https://cmjunghoon.github.io/posts/Install_Ruby/#1-rbenv%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-ruby-%EC%84%A4%EC%B9%98https://deku.posstree.com/ko/jekyll/installation/https://renee.tistory.com/46"
  }
  
]

